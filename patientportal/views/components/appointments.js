var weekStart = new Date();
weekStart.setDate(new Date().getDate() - new Date().getDay() + 1);
weekStart.setHours(7);
weekStart.setMinutes(0);
weekStart.setSeconds(0);
weekStart.setMilliseconds(0);

var startTime = { hours: 7, minutes: 0, seconds: 0, milliseconds: 0 };
var endTime = { hours: 18, minutes: 0, seconds: 0, milliseconds: 0 };
var appointmentDurationMins = 15;  // Minutes
var appointmentDurationHours = appointmentDurationMins / 60;
var dayDurationHours = endTime.hours - startTime.hours;
var slotsEachDay = dayDurationHours / appointmentDurationHours;
var daysEachWeek = 6; // m | t | w | t | f | s
var days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

/**
* Get an empty schedule with 44 slots per day
*/
function emptySlots() {
    let cols = [];
    for (let i = 0; i < days.length; i++) {
        let rows = [];
        let hour = 7;
        let minutes = 0;
        let startHour = 7;
        let startMinutes = 0;
        for (let j = 0; j < slotsEachDay; j++) {
            minutes = startMinutes + (j * 15) % 60;
            if (j * 15 >= 60) {
                hour = startHour + Math.floor((j * 15) / 60);
            }
            let dateTime = new Date(weekStart);
            dateTime.setDate(dateTime.getDate() + i);
            dateTime.setHours(hour);
            dateTime.setMinutes(minutes);
            dateTime.setMilliseconds(0);
            rows.push({ time: dateTime, appointments: [], full: false });
        }

        cols.push({
            day: days[i],
            slots: rows
        });
    }

    return cols;
}

function emptySchedule() {
    let schedule = [];
    for (let i = 0; i < days.length; i++) {
        let slots = [];
        let hour = 7;
        let minutes = 0;
        let startHour = 7;
        let startMinutes = 0;

        for (let j = 0; j < slotsEachDay; j++) {
            minutes = startMinutes + (j * 15) % 60;
            if (j * 15 >= 60) {
                hour = startHour + Math.floor((j * 15) / 60);
            }
            let dateTime = new Date(weekStart);
            dateTime.setDate(dateTime.getDate() + i);
            dateTime.setHours(hour);
            dateTime.setMinutes(minutes);
            dateTime.setMilliseconds(0);
            slots.push({ time: dateTime, appointment: false });
        }

        schedule.push({day: days[i], slots: slots});
    }
    return schedule;
}

/**
 * This class is composed of three components:
 * <BookAppointment/>, 
 * <AppointmentSlots/>, 
 * <AppointmentSchedule/>
 */
class Appointments extends React.Component {
    constructor(props) {
        super(props);

        // initial state
        this.state = { 
            slots: emptySlots(), // Slots
            schedule: false,     // Appointment schedule
            slot: false,        // Has user selected a free slot to book?
            appointment: false, // Has user selected appointment from their schedule?
            cancelling: false   // User is cancelling
        };

        // Binds
        this.selectSlot = this.selectSlot.bind(this);
        this.selectAppointment = this.selectAppointment.bind(this);
        this.book = this.book.bind(this);
        this.reschedule = this.reschedule.bind(this);
        this.cancel = this.cancel.bind(this);
    }

    /**
     * On behalf of the user this method requests a list of all appointments they have booked from the API and
     * stuffs the data into a custom data structure generated by the function emptySchedule. This data is then used to render
     * <AppointmentSchedule/> for when the user has already booked an appointment.
     * TODO: Make compatible with doctors but not admins.
     */
    async getSchedule() {
        let schedule = emptySchedule();
        try {
            let response = await HttpRequest("GET", "/api/appointments/schedule");
            response = JSON.parse(response);
            let results = response.result;
            if (results && results.length > 0) {
                for (let i = 0; i < schedule.length; i++) {
                    let slots = schedule[i].slots;
                    for (let j = 0; j < slots.length; j++) {
                        let time = slots[j].time;

                        let index = response.result.findIndex((appointment) => {
                            return new Date(appointment.dateTime) - time == 0;
                        });

                        if (index != -1){
                            slots[j].appointment = results[index];
                        }
                    }
                }
                this.setState({schedule: schedule});
            } else if (this.state.schedule) {
                this.setState({schedule: false});
            }
        } catch (e) {
            console.error(e);
        }
    }

    /**
     * TODO: fix
     * This method requests a list of all booked appointments from the API and stuffs the data into 
     * a custom data structure generated by the function emptySlots. This data is then used to render
     * <AppointmentSlots/> for when the user needs to book an appointment slot.
     */
    async getAvailableSlots() {
        try {
            this.setState({slots: emptySlots()});
            let response = await HttpRequest("GET", "/api/appointments/slots");
            response = JSON.parse(response);

            let noClinicians = response.clinicians;
            let appointments = response.result;

            for (let i = 0; i < this.state.slots.length; i++) {
                let slots = this.state.slots[i].slots;
                for (let j = 0; j < slots.length; j++) {
                    let time = slots[j].time;

                    // Find first index
                    let index = appointments.findIndex((appointment) => {
                        return (new Date(appointment.dateTime) - new Date(time)) == 0;
                    });

                    // Find others
                    while (index != -1) {
                        slots[j].appointments.push(appointments[index]);
                        appointments.splice(index, 1);
                        slots[j].full = slots[j].appointments.length == noClinicians;
                        index = appointments.findIndex((appointment) => {
                            return (new Date(appointment.dateTime) - new Date(time)) == 0;
                        });
                    }
                }
            }

            this.setState({ slots: this.state.slots });
        } catch (e) {
            console.error(e);
        }
    }

    /**
     * Update the views with data fetched from the API
     */
    update(){
        this.getSchedule();
        this.getAvailableSlots();
    }
    
    /**
     * Run this code when the component has been mounted to DOM.
     */
    componentDidMount() {
        this.update();
        this.setState({waiting: true});
        setTimeout((self) => {self.setState({waiting: false})}, 500, this);
        this.interval = setInterval((self) => { self.update() }, 1000, this);
    }

    /**
     * Run this code when the component is unmounted from DOM.
     */
    componentWillUnmount() {
        clearInterval(this.interval);
    }
    
    /**
     * Select an appointment slot
     * @param {object} item
     */
    selectSlot(item) {
        if (item.appointments) {
            this.setState({ slot: item });
        }
    }

    selectAppointment(item) {
        if (item.appointment) {
            this.setState({appointment: item.appointment});
        }
    }

    /**
     * Books an appointment with a clinician at a selected dateTime.
     * @param {object} clinician - This object is recieved from <BookAppointment/> component class.
     */
    async book(clinician) {
        try {
            await HttpRequest("POST", "/api/appointments/create", [], JSON.stringify({id: clinician._id, dateTime: new Date(this.state.slot.time)}));
            this.setState({ slot: false });
        } catch (e) {
            console.error(e);
        }
    }

    async reschedule(appointment) {
        console.log(appointment);
    }

    async cancel(appointment) {
        try {
            await HttpRequest("POST", "/api/appointments/cancel", [], JSON.stringify({appointmentID: appointment._id}));
            this.setState({cancelling: false, appointment: false});
        } catch (e) {
            console.error(e);
        }
    }

    render() {
        if (this.state.waiting) {
            return <div><h2>Loading</h2><div className="spinner-border" role="status">
            <span className="sr-only">Loading...</span>
            </div></div>;
        } else if (this.state.cancelling) {
            return <CancelAppointment appointment={this.state.appointment} confirm={this.cancel} backHandle={() => {this.setState({cancelling: false})}}/>
        } else if (this.state.appointment) {
            return <ManageAppointment appointment={this.state.appointment} rescheduleClick={this.reschedule} cancelClick={() => {this.setState({cancelling: true})}} backHandle={() => {this.setState({appointment: false})}} />;
        } else if (this.state.schedule){
            return <AppointmentSchedule schedule={this.state.schedule} handleClick={this.selectAppointment} backHandle={() => {window.location.href="/"}}/>;
        } else if (this.state.slot) {   
            return <BookAppointment time={this.state.slot.time} appointments={this.state.slot.appointments} handleClick={this.book} backHandle={()=>{this.setState({slot: false})}}/>;
        } else {
            return <AppointmentSlots slots={this.state.slots} handleClick={this.selectSlot} backHandle={() => {window.location.href="/"}}/>;
        }
    }  
}

ReactDOM.render(<Appointments />, document.getElementById("menu"));